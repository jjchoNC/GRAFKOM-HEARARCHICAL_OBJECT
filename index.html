<!-- Licensed under a BSD license. See license.html for license -->
<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
    <title>WebGL - load obj</title>
    <link type="text/css" href="index.css" rel="stylesheet" />
</head>

<body>
    <canvas id="canvas"></canvas>
    <div>
        <label for="sliderX">
            Rotation X:
            <input id="sliderX" type="range" min="-30" max="360" value="0" step="1">
        </label>
        <label for="sliderY">
            Rotation Y:
            <input id="sliderY" type="range" min="-30" max="360" value="60" step="1">
        </label>
        <label for="sliderZ">
            Rotation Z:
            <input id="sliderZ" type="range" min="-30" max="360" value="0" step="1">
        </label>
        <label for="sliderEngsel">
            Engsel:
            <input id="sliderEngsel" type="range" min="-25" max="15" value="0" step="1">
        </label>
    </div>
</body>
<!--
for most samples webgl-utils only provides shader compiling/linking and
canvas resizing because why clutter the examples with code that's the same in every sample.See https:and https:
for webgl-utils, m3, m4, and webgl-lessons-ui.
-->
<script src="webgl-utils.js"></script>
<script src="m4.js"></script>
<script>
    "use strict";


    function parseOBJ(text) {
        const objPositions = [[0, 0, 0]];
        const objTexcoords = [[0, 0]];
        const objNormals = [[0, 0, 0]];

        const objVertexData = [
            objPositions,
            objTexcoords,
            objNormals,
        ];

        let webglVertexData = [
            [],
            [],
            [],
        ];

        const materialLibs = [];
        const geometries = [];
        let geometry;
        let groups = ['default'];
        let material = 'default';
        let object = 'default';

        const noop = () => { };

        function newGeometry() {
            if (geometry && geometry.data.position.length) {
                geometry = undefined;
            }
        }

        function setGeometry() {
            if (!geometry) {
                const position = [];
                const texcoord = [];
                const normal = [];
                webglVertexData = [
                    position,
                    texcoord,
                    normal,
                ];
                geometry = {
                    object,
                    groups,
                    material,
                    data: {
                        position,
                        texcoord,
                        normal,
                    },
                };
                geometries.push(geometry);
            }
        }

        function addVertex(vert) {
            const ptn = vert.split('/');
            ptn.forEach((objIndexStr, i) => {
                if (!objIndexStr) {
                    return;
                }
                const objIndex = parseInt(objIndexStr);
                const index = objIndex + (objIndex >= 0 ? 0 : objVertexData[i].length);
                webglVertexData[i].push(...objVertexData[i][index]);
            });
        }

        const keywords = {
            v(parts) {
                objPositions.push(parts.map(parseFloat));
            },
            vn(parts) {
                objNormals.push(parts.map(parseFloat));
            },
            vt(parts) {
                objTexcoords.push(parts.map(parseFloat));
            },
            f(parts) {
                setGeometry();
                const numTriangles = parts.length - 2;
                for (let tri = 0; tri < numTriangles; ++tri) {
                    addVertex(parts[0]);
                    addVertex(parts[tri + 1]);
                    addVertex(parts[tri + 2]);
                }
            },
            s: noop,
            mtllib(parts, unparsedArgs) {
                materialLibs.push(unparsedArgs);
            },
            usemtl(parts, unparsedArgs) {
                material = unparsedArgs;
                newGeometry();
            },
            g(parts) {
                groups = parts;
                newGeometry();
            },
            o(parts, unparsedArgs) {
                object = unparsedArgs;
                newGeometry();
            },
        };

        const keywordRE = /(\w*)(?: )*(.*)/;
        const lines = text.split('\n');
        for (let lineNo = 0; lineNo < lines.length; ++lineNo) {
            const line = lines[lineNo].trim();
            if (line === '' || line.startsWith('#')) {
                continue;
            }
            const m = keywordRE.exec(line);
            if (!m) {
                continue;
            }
            const [, keyword, unparsedArgs] = m;
            const parts = line.split(/\s+/).slice(1);
            const handler = keywords[keyword];
            if (!handler) {
                console.warn('unhandled keyword:', keyword);
                continue;
            }
            handler(parts, unparsedArgs);
        }

        for (const geometry of geometries) {
            geometry.data = Object.fromEntries(
                Object.entries(geometry.data).filter(([, array]) => array.length > 0));
        }

        return {
            geometries,
            materialLibs,
        };
    }

    async function main() {
        /** @type {HTMLCanvasElement} */
        const canvas = document.querySelector("#canvas");
        const gl = canvas.getContext("webgl");
        var sliderY = document.getElementById("sliderY");
        var sliderX = document.getElementById("sliderX");
        var sliderZ = document.getElementById("sliderZ");
        var sliderEngsel = document.getElementById("sliderEngsel");
        if (!gl) {
            return;
        }

        const vs = `
        attribute vec4 a_position;
        attribute vec3 a_normal;

        uniform mat4 u_projection;
        uniform mat4 u_view;
        uniform mat4 u_world;

        varying vec3 v_normal;

        void main() {
            gl_Position = u_projection * u_view * u_world * a_position;
            v_normal = mat3(u_world) * a_normal;
        }
        `;

        const fs = `
        precision mediump float;

        varying vec3 v_normal;

        uniform vec4 u_diffuse;
        uniform vec3 u_lightDirection;

        void main () {
            vec3 normal = normalize(v_normal);
            float fakeLight = dot(u_lightDirection, normal) * .5 + .5;
            gl_FragColor = vec4(u_diffuse.rgb * fakeLight, u_diffuse.a);
        }
        `;


        const meshProgramInfo = webglUtils.createProgramInfo(gl, [vs, fs]);

        const response = await fetch('resources/obj/kipas_triangulate_full_fix.obj', { mode: 'cors' });
        const text = await response.text();
        const obj = parseOBJ(text);

        const parts = obj.geometries.map(({ data }) => {

            const bufferInfo = webglUtils.createBufferInfoFromArrays(gl, data);
            return {
                material: {
                    u_diffuse: [Math.random(), Math.random(), Math.random(), 1],
                },
                bufferInfo,
            };
        });

        const cameraTarget = [0, 0, 0];
        const cameraPosition = [0, 0, 4];
        const zNear = 0.1;
        const zFar = 50;

        function degToRad(deg) {
            return deg * Math.PI / 180;
        }

        function clamp(value, min, max) {
            return Math.max(min, Math.min(max, value));
        }

        function render(time) {
            time *= 0.001; // Convert time to seconds

            webglUtils.resizeCanvasToDisplaySize(gl.canvas);
            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
            gl.enable(gl.DEPTH_TEST);
            gl.enable(gl.CULL_FACE);

            const fieldOfViewRadians = degToRad(60);
            const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
            const projection = m4.perspective(fieldOfViewRadians, aspect, zNear, zFar);

            const up = [0, 1, 0];
            var camera = m4.lookAt(cameraPosition, cameraTarget, up);
            const view = m4.inverse(camera);

            const sharedUniforms = {
                u_lightDirection: m4.normalize([-1, 3, 5]),
                u_view: view,
                u_projection: projection,
            };

            gl.useProgram(meshProgramInfo.program);
            webglUtils.setUniforms(meshProgramInfo, sharedUniforms);

            const scaleFactor = 0.25;
            const translateY = 0.25;
            const translateX = -0.25;
            const scalingMatrix = m4.scaling(scaleFactor, scaleFactor, scaleFactor);
            const translationMatrix = m4.translation(translateX, translateY, 0);

            const bladeSpinAngle = time * 10;
            const bladeSpinMatrix = m4.zRotation(bladeSpinAngle);

            const maxAngle = degToRad(30);
            const minAngle = degToRad(-30);
            var motorSpinDirection = 1;

            var currentMotorSpinAngle = 0;
            currentMotorSpinAngle = clamp(Math.sin(time) * Math.PI / 4, minAngle, maxAngle);

            if (currentMotorSpinAngle <= minAngle || currentMotorSpinAngle >= maxAngle) {
                motorSpinDirection *= -1;
            }

            const motorSpinMatrix = m4.yRotation(currentMotorSpinAngle);

            for (let index = 0; index < parts.length; ++index) {
                const { bufferInfo, material } = parts[index];

                let u_world;

                if (index == 1 || index == 2 || index == 3) {
                    
                    u_world = m4.multiply(translationMatrix, scalingMatrix);
                    u_world = m4.yRotate(u_world, degToRad(parseFloat(sliderY.value)));
                    u_world = m4.xRotate(u_world, degToRad(parseFloat(sliderX.value)));
                    u_world = m4.zRotate(u_world, degToRad(parseFloat(sliderZ.value)));

                    const engselSpinMatrix = m4.xRotation(degToRad(parseFloat(sliderEngsel.value)));
                    const pivotEngsel = [0, -2, 3];

                    var toPivotMatrix = m4.translation(-pivotEngsel[0], -pivotEngsel[1], -pivotEngsel[2]);
                    var fromPivotMatrix = m4.translation(pivotEngsel[0], pivotEngsel[1], pivotEngsel[2]);

                    u_world = m4.multiply(u_world, fromPivotMatrix);
                    u_world = m4.multiply(u_world, engselSpinMatrix);
                    u_world = m4.multiply(u_world, toPivotMatrix);

                    if (index == 2 || index == 3) {
                        const pivotMotor = [0, 0, 2.5];

                        toPivotMatrix = m4.translation(-pivotMotor[0], -pivotMotor[1], -pivotMotor[2]);
                        fromPivotMatrix = m4.translation(pivotMotor[0], pivotMotor[1], pivotMotor[2]);

                        u_world = m4.multiply(u_world, fromPivotMatrix);
                        u_world = m4.multiply(u_world, motorSpinMatrix);
                        u_world = m4.multiply(u_world, toPivotMatrix);
                        if (index == 3) {
                            u_world = m4.multiply(u_world, bladeSpinMatrix);
                        }
                    }
                }

                else {
                    u_world = m4.multiply(translationMatrix, scalingMatrix);
                    u_world = m4.yRotate(u_world, degToRad(parseFloat(sliderY.value)));
                    u_world = m4.xRotate(u_world, degToRad(parseFloat(sliderX.value)));
                    u_world = m4.zRotate(u_world, degToRad(parseFloat(sliderZ.value)));
                }

                webglUtils.setBuffersAndAttributes(gl, meshProgramInfo, bufferInfo);
                webglUtils.setUniforms(meshProgramInfo, {
                    u_world,
                    u_diffuse: material.u_diffuse,
                });
                webglUtils.drawBufferInfo(gl, bufferInfo);
            }

            requestAnimationFrame(render);
        }


        requestAnimationFrame(render);
    }

    main();
</script>

</html>